<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.111.3"><meta name=generator content="Relearn 5.12.6+tip"><meta name=description content="Thinging for all things."><meta name=author content="programmingcat"><title>Distribute Service - Thinging X</title><link href=http://thinkingx.xyz/distribute-service/index.html rel=canonical type=text/html title="Distribute Service - Thinging X"><link href=/distribute-service/index.xml rel=alternate type=application/rss+xml title="Distribute Service - Thinging X"><link href=/images/favicon.svg?1703641023 rel=icon type=image/svg+xml><link href=/css/fontawesome-all.min.css?1703641023 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fontawesome-all.min.css?1703641023 rel=stylesheet></noscript><link href=/css/nucleus.css?1703641023 rel=stylesheet><link href=/css/auto-complete.css?1703641023 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/auto-complete.css?1703641023 rel=stylesheet></noscript><link href=/css/perfect-scrollbar.min.css?1703641023 rel=stylesheet><link href=/css/fonts.css?1703641023 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fonts.css?1703641023 rel=stylesheet></noscript><link href=/css/theme.css?1703641023 rel=stylesheet><link href=/css/theme-learn.css?1703641023 rel=stylesheet id=variant-style><link href=/css/variant.css?1703641023 rel=stylesheet><link href=/css/print.css?1703641023 rel=stylesheet media=print><link href=/css/format-print.css?1703641023 rel=stylesheet><link href=/css/ie.css?1703641023 rel=stylesheet><script src=/js/url.js?1703641023></script>
<script src=/js/variant.js?1703641023></script>
<script>window.index_js_url="/index.search.js";var root_url="/",baseUriFull,baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="Copy to clipboard",window.T_Copied_to_clipboard="Copied to clipboard!",window.T_Copy_link_to_clipboard="Copy link to clipboard",window.T_Link_copied_to_clipboard="Copied link to clipboard!",window.T_No_results_found="No results found for \u0022{0}\u0022",window.T_N_results_found="{1} results found for \u0022{0}\u0022",baseUriFull="http://thinkingx.xyz/",window.variants&&variants.init(["learn","relearn-light","relearn-dark","relearn-bright","neon","blue","green","red"])</script></head><body class="mobile-support print" data-url=/distribute-service/index.html><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable><div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle class=topbar-link title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/index.html><span itemprop=name>Overview</span></a><meta itemprop=position content="1">></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Distribute Service</span><meta itemprop=position content="2"></li></ol></div></div></nav><main id=body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><div id=head-tags><div class=tags><a class=tag-link href=/tags/distribute-service/index.html>Distribute Service</a></div></div><article class=chapter><div class=article-subheading>Chapter 3</div><h1 id=distribute-service>Distribute Service</h1><p>总结分布式服务、互联网技术相关的知识。</p><ul class="children children-li children-sort-"><li><a href=/distribute-service/backend-storage/index.html>后端存储以及存储服务</a></li><li><a href=/distribute-service/bff/index.html>BFF</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Distribute Service</h1><article class=default><h1 id=后端存储以及存储服务>后端存储以及存储服务</h1><blockquote><p>把后端存储当成一个贯穿很多知识点的 Topic，这样可以把相关的知识点串联起来，形成一个完整的知识体系。</p></blockquote><p>后端存储是分布式服务中最重要的一部分。存储承担了数据的持久化、读写、查询等功能，一个安全可靠、快速稳定的存储基础设施是构建稳定的业务系统的基础。</p><p>根据不同的业务场景，选择使用不同的存储技术，是一种能力。</p><p>MySQL、Redis、ElasticSearch、HBase、Hive、MongoDB、RocksDB、CockroachDB 等等，这些存储还真就是谁都替代不了谁，每一种都有它擅长的地方，有它适用的场景，当然也有很突出的短板。如何根据业务系统的特点，选择合适的存储来构建我们的系统，是需要学习和掌握的。</p><p>目录列表</p><ul class="children children-li children-sort-"><li><a href=/distribute-service/backend-storage/cache/index.html>缓存设计</a></li></ul><p>TODOs</p><ul><li>分库分表<ul><li>ShardingSphere JDBC</li></ul></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of 后端存储以及存储服务</h1><article class=default><h1 id=缓存设计>缓存设计</h1><p>互联网服务中，缓存是提高系统性能的重要手段。缓存的设计需要考虑的因素很多，包括缓存的类型、缓存的位置、缓存的更新策略、缓存的一致性等等。本文将从这些方面来介绍缓存的设计。</p><h2 id=缓存>缓存</h2><blockquote><p>缓存，是一种存储数据的组件，它的作用是让对数据的请求更快地返回。实际上，凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为缓存。</p></blockquote><p>技术为业务服务，缓存也不例外；在业务系统中，主要会用到以下几种缓存：</p><ul><li>本地缓存 (aka 进程内缓存)</li><li>分布式缓存</li><li>类似于 CDN 的静态数据缓存</li></ul><h3 id=进程内缓存>进程内缓存</h3><p>一般也叫 <code>Local Cache</code>, 是指缓存在应用进程内部的缓存，比如 Java 中的 <code>HashMap</code>、<code>ConcurrentHashMap</code> 等。这种缓存的特点是速度快，但是缓存的数据量有限，一般只能缓存一些热点数据；此外，这类缓存会引入多实例下数据短暂不一致的问题，所以在使用的时候要格外小心。</p><p>经常使用的 <code>Local cache</code> 有：<code>Google Guava Cache</code>、<code>Caffeine</code>、<code>ConcurrentHashMap</code>、<code>Ehcache</code> 等。目前 <code>Caffeine</code> 是性能最好的 <code>Local Cache</code>。此外，<code>leveldb</code> 也是一种本地缓存的实现，但是它是基于磁盘的，所以性能不如上面几种。</p><h4 id=什么时候需要用本地缓存什么场景不适合用>什么时候需要用本地缓存？什么场景不适合用？</h4><p>举几个场景</p><ul><li>黑名单用户 ID / 白名单用户 ID；这种数据量不大，但是访问频率很高，所以可以用本地缓存，在启动时加载，运行过程中随着 Admin 的添加或者删除而更新</li><li>用户 ID 和 用户名、头像、昵称等的对应关系，由于某些原因我们一般指存储用户的 ID，当需要用户的其他信息时就需要从数据库中查询这些数据回来，如果每次都从 DB 中获取，显然对 DB 的压力很大，并且每次访问 DB 不是很有必要</li><li>分布式配置中心，为了降低业务服务对配置中心的压力，一般都是将数据缓存在本地，当有新的配置发布后，会通知业务服务中配置中心的 client，然后拉取新的配置，或者推送新的配置</li></ul><p><strong>总结一下</strong></p><ol><li>数据读多写少且对一致性要求不高的场景；如果一致性要求非常高，需要考虑使用分布式缓存，并且还要考虑数据库与分布式缓存的一致性问题</li><li>对性能要求极其严苛的场景，比如秒杀、抢购等</li><li>只读数据的场景</li><li>分布式缓存的普适性更强一些，很多场景都可以用分布式缓存来解决，如非必要，不建议使用本地缓存 (也就是说用了也要慎重)</li></ol><h4 id=优势是什么劣势是什么>优势是什么？劣势是什么？</h4><p><code>Local Cache</code> 和应用服务处于同一个进程内，且存储在内存中，一个字：快；无论对于 RT、QPS 还是吞吐量，都有极大增益。此外，也节省了内网带宽。</p><p>依据服务无状态设计的原则：<strong>尽量把数据的状态和存储放在专门的数据存储服务中，实例节点本身只做计算，不把数据状态和某个实例做耦合，这样在水平扩展时才能收放自如</strong>。本地缓存其实在一定程度上引入了状态，所以一个最需要关心的问题就是数据一致性，这一点有别于分布式缓存。</p><ul><li>本地缓存：每个实例都有一份缓存，需要协调数据一致性问题</li><li>分布式缓存：缓存数据集中存放在独立的缓存服务中，每个实例是不存在缓存数据的，但是需要考虑缓存和 SOR (Source of Record) 的一致性问题</li></ul><h4 id=目前有哪些本地缓存的实现方案各自的优缺点>目前有哪些本地缓存的实现方案，各自的优缺点？</h4><ul><li>编程语言的内置数据结构，比如 Java 中的 <code>HashMap</code>、<code>ConcurrentHashMap</code> 等</li><li>Google guava</li><li>Caffeine</li><li>Encache</li><li>Leveldb / Rocksdb</li></ul><h4 id=本地缓存关注的技术点是什么>本地缓存关注的技术点是什么？</h4><ul><li>缓存命中率</li><li>缓存容量</li><li>缓存淘汰策略</li><li>缓存一致性</li></ul><h3 id=分布式缓存>分布式缓存</h3><p>TODO</p><h2 id=缓存规范>缓存规范</h2><ul><li>JSR107</li><li>Spring Cache</li></ul><h2 id=缓存实践>缓存实践</h2><p>缓存可以应对高并发大流量的场景。</p><p>在做缓存设计时，有一些误区要避开：</p><ol><li>把缓存作为服务间传递数据的通道，这个要避免</li><li>使用缓存没有考虑雪崩的情况，这个要考虑</li><li>多服务共享一个缓存实例，这个最好要避免，多个服务之间缓存做垂直拆分</li></ol><p>找几个例子分析一下</p><hr><h2 id=references>References</h2><ul><li><input checked disabled type=checkbox> <a href=https://shniu.gitbook.io/cs/system-design/backend-store/cache-design target=_blank>缓存设计</a></li><li><input checked disabled type=checkbox> <a href=https://mp.weixin.qq.com/s/Car6EkaNzaJ7gaFa2EZxOw target=_blank>进程内缓存，究竟怎么玩？</a></li><li><input checked disabled type=checkbox> <a href=https://tech.meituan.com/2017/03/17/cache-about.html target=_blank>美团-缓存那些事儿</a></li><li><input disabled type=checkbox> <a href=https://weread.qq.com/web/reader/98a323b05e0b5e98afa107ckc81322c012c81e728d9d180 target=_blank>深入分布式缓存：从原理到实践</a></li></ul><h3 id=frameworks>Frameworks</h3><ul><li><a href=https://github.com/ben-manes/caffeine/wiki/Home-zh-CN target=_blank>Caffeine Doc</a></li></ul><p><a href=https://bbs.huaweicloud.com/blogs/365239 target=_blank>https://bbs.huaweicloud.com/blogs/365239</a>
<a href=https://mp.weixin.qq.com/s/36kVm4pfiy2vQEMToZ9--g target=_blank>https://mp.weixin.qq.com/s/36kVm4pfiy2vQEMToZ9--g</a>
<a href=https://cloud.tencent.com/developer/article/1546995 target=_blank>https://cloud.tencent.com/developer/article/1546995</a>
<a href=https://juejin.cn/post/6844903961078530062 target=_blank>https://juejin.cn/post/6844903961078530062</a>
<a href=https://mp.weixin.qq.com/s/YBpOz1dQ0sG15vGL7N0PeQ target=_blank>https://mp.weixin.qq.com/s/YBpOz1dQ0sG15vGL7N0PeQ</a>
<a href=https://shniu.gitbook.io/cs/middleware/redis target=_blank>https://shniu.gitbook.io/cs/middleware/redis</a>
<a href=https://shniu.gitbook.io/cs/system-design/backend-store/cache-design target=_blank>https://shniu.gitbook.io/cs/system-design/backend-store/cache-design</a>
<a href=https://tech.meituan.com/2017/03/17/cache-about.html target=_blank>https://tech.meituan.com/2017/03/17/cache-about.html</a>
<a href=http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html target=_blank>http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html</a>
<a href=https://juejin.cn/post/7151937376578142216 target=_blank>https://juejin.cn/post/7151937376578142216</a>
<a href=https://juejin.cn/column/7140852038258147358 target=_blank>https://juejin.cn/column/7140852038258147358</a></p><footer class=footline></footer></article></section><article class=default><h1 id=bff>BFF</h1><p>Backend for Frontend 是一种模式，在构建 API 时当然可以不选择使用 BFF，取而代之的是对多个 UI 终端提供一个统一的 API，但是不可避免的会带来一些问题：</p><ol><li>不同的 UI 终端展示的数据是不一样的，比如 Web H5 和 App 之间会存在较大的差异</li><li>不同的 UI 终端可能会有不同的逻辑，比如有些数据是 Web 用，有些则是 App 用，这样都放在一个接口里的话，对不同的终端来说，都会有一些无用的数据，或者是无用的逻辑，这样会导致接口的复杂度增加，维护成本增加；从节约流量和资源的角度说，移动端应该尽可能少的去拉取数据</li><li>统一的 API 在开发新功能时，可能会对不同 UI 终端都产生影响，而且功能逻辑会相互耦合；也就是说一个接口承担了更多的职责</li></ol><p>总结来看：由于不同终端的差异性，导致对后端 API 的数据产生了不同的需求，驱动我们去考虑针对不同的 UI 来定制不同的接口。</p><p><strong>通用的 API 后端和团队组成如下</strong></p><p><a href=#image-14987a46f961b6bacbeca368e9a53ebe class=lightbox-link><img src="/images/bff-single-api.jpeg?classes=shadow,inline&amp;height=300px" alt="通用 API 后端" class="shadow inline" style=height:300px;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-14987a46f961b6bacbeca368e9a53ebe><img src="/images/bff-single-api.jpeg?classes=shadow,inline&amp;height=300px" alt="通用 API 后端" class=lightbox-image loading=lazy></a>
<a href=#image-f8e04ef54d74e120b16515b5decf7c7f class=lightbox-link><img src="/images/general-purpose-api-teams.jpeg?classes=shadow,inline&amp;height=300px" alt="通用 API 团队组成" class="shadow inline" style=height:300px;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-f8e04ef54d74e120b16515b5decf7c7f><img src="/images/general-purpose-api-teams.jpeg?classes=shadow,inline&amp;height=300px" alt="通用 API 团队组成" class=lightbox-image loading=lazy></a></p><h2 id=使用-bff>使用 BFF</h2><blockquote><p>The goal of the BFF pattern is to decouple the front-end applications from the back-end services and to reuse the APIs while ensuring that it doesn&rsquo;t cause over-fetching or over-requesting on the client-side. This is accomplished by developing a dedicated back-end for each front-end service. The BFF transforms the data into the correct format that the client application needs.</p></blockquote><p><a href=#image-6a73bade2f7b52fd26cba3cacc6aff99 class=lightbox-link><img src="/images/bff-overview.jpeg?classes=shadow&amp;height=300px" alt="BFF Overview" class=shadow style=height:300px;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-6a73bade2f7b52fd26cba3cacc6aff99><img src="/images/bff-overview.jpeg?classes=shadow&amp;height=300px" alt="BFF Overview" class=lightbox-image loading=lazy></a></p><ol><li>BFF 的接口通常是由前端开发人员来定义，由后端开发人员来实现</li><li>BFF API 一般以 UI 为依据，这样更集中</li><li>至于是不是必须为每个类型的终端都定义不同的 BFF，这个需要根据实际情况来判断，或者团队来决定采用何种模式；比如 iOS 和 Android 的 UI 体验几乎完全一致，我们有必要指提供一套 BFF，而不是一个 iOS BFF 和一个 Android BFF；所以具体情况还要具体分析，没有一个标准答案</li><li>在调用多个下游服务时，使用 RxJava 或 <a href=https://twitter.github.io/finagle/ target=_blank>Finagle</a> 这类响应式编程风格的方式会更加的易于管理，而且可以更好的控制并发度，提高性能</li><li>在使用 BFF 时带来的最大困扰是重复代码，这个可能无法避免，但是在合理的情况下可以考虑复用代码、抽象代码达到消除重复的目的</li><li>一个指导规则可能是：如果被提取的功能不必同时更新，则使用共享库，但如果需要，则使用服务。</li><li>谈论复制和重用，不要试图从一开始就让一切通用。如果你尝试，并且它在整个组织中使用，就会引起摩擦，因为很多人都想做出贡献。在考虑通用用法之前，请专注于您的功能和特定用例。“特殊功能优先于通用用法”策略效果更好。在考虑提取代码时，不要忘记有用的“三法则”。</li></ol><p>关于 BFF 的实践可以看一下 <a href=https://www.thoughtworks.com/insights/blog/bff-soundcloud title="BFF Soundcloud" target=_blank>BFF @ SoundCloud</a> 这篇文章，里面有一些很好的实践经验。</p><p><strong>什么时候用 BFF ?</strong> 当你有多个微服务，并且需要应对不同的 UI 终端，而且这些终端之间存在差异性，可以考虑使用 BFF 模式。</p><h2 id=event-driven-bff>Event-driven BFF</h2><p>AWS 提出了一个 event-driven BFF 的东西: <a href=https://aws.amazon.com/cn/blogs/mobile/backends-for-frontends-pattern/ title="AWS event-driven BFF" target=_blank>Backends for Frontends Pattern by AWS</a></p><p><a href=#image-98eaa7b5ff36c90bdaaac674392af528 class=lightbox-link><img src="/images/aws-event-driven-bff-1.png?classes=shadow" alt="AWS event driven BFF" class=shadow style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-98eaa7b5ff36c90bdaaac674392af528><img src="/images/aws-event-driven-bff-1.png?classes=shadow" alt="AWS event driven BFF" class=lightbox-image loading=lazy></a></p><ul><li>右边是微服务或单体服务发出的 event，这些 event 在 Domain 发生更新时发出</li><li>中间是 Event bus，接收 event 后转发给左边的 BFF 层的订阅者</li><li>左边是 BFF 的实现，不同的 BFF 可以有不同的数据库投影，根据具体的需求来定制数据结构，当然也可以支持 CDC 模式</li></ul><p>还有一种更加云原生的方式来构建服务</p><p><a href=#image-010686978d1b14730d0acf4ae2371ca8 class=lightbox-link><img src="/images/aws-event-driven-bff-2.png?classes=shadow" alt="AWS event driven BFF" class=shadow style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-010686978d1b14730d0acf4ae2371ca8><img src="/images/aws-event-driven-bff-2.png?classes=shadow" alt="AWS event driven BFF" class=lightbox-image loading=lazy></a></p><h2 id=reference>Reference</h2><ul><li><a href=https://samnewman.io/patterns/architectural/bff/ target=_blank>Pattern: Backends For Frontends</a> - Sam Newman 写的关于 BFF 模式的文章</li><li><a href=https://developer.aliyun.com/article/841664 target=_blank>BFF 架构简介</a></li><li><a href=https://www.thoughtworks.com/insights/blog/bff-soundcloud title="BFF Soundcloud" target=_blank>BFF @ SoundCloud</a></li><li><a href=https://www.codemag.com/Article/2203081/A-Deep-Dive-into-the-Back-End-for-Front-End-Pattern target=_blank>A Deep Dive into the Back-End for Front-End Pattern</a></li><li><a href=https://aws.amazon.com/cn/blogs/mobile/backends-for-frontends-pattern/ title="AWS event-driven BFF" target=_blank>Backends for Frontends Pattern</a></li><li><a href=https://netflixtechblog.com/seamlessly-swapping-the-api-backend-of-the-netflix-android-app-3d4317155187 target=_blank>Seamlessly Swapping the API backend of the Netflix Android app</a> - Netflix Android App 的 BFF 实践</li><li><a href=https://medium.com/mobilepeople/backend-for-frontend-pattern-why-you-need-to-know-it-46f94ce420b0 target=_blank>Backend for frontend (BFF) pattern— why do you need to know it?</a></li><li><a href=https://learn.microsoft.com/en-us/azure/architecture/patterns/backends-for-frontends target=_blank>Backends for Frontends pattern by Azure</a></li></ul><footer class=footline></footer></article></section></div></main></div><script src=/js/clipboard.min.js?1703641023 defer></script>
<script src=/js/perfect-scrollbar.min.js?1703641023 defer></script>
<script src=/js/d3/d3-color.min.js?1703641023 defer></script>
<script src=/js/d3/d3-dispatch.min.js?1703641023 defer></script>
<script src=/js/d3/d3-drag.min.js?1703641023 defer></script>
<script src=/js/d3/d3-ease.min.js?1703641023 defer></script>
<script src=/js/d3/d3-interpolate.min.js?1703641023 defer></script>
<script src=/js/d3/d3-selection.min.js?1703641023 defer></script>
<script src=/js/d3/d3-timer.min.js?1703641023 defer></script>
<script src=/js/d3/d3-transition.min.js?1703641023 defer></script>
<script src=/js/d3/d3-zoom.min.js?1703641023 defer></script>
<script src=/js/mermaid.min.js?1703641023 defer></script>
<script>window.themeUseMermaid=JSON.parse("{}")</script><script src=/js/theme.js?1703641023 defer></script></body></html>