<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.111.3"><meta name=generator content="Relearn 5.12.6+tip"><meta name=description content="Thinging for all things."><meta name=author content="programmingcat"><title>Overview - Thinging X</title><link href=http://thinkingx.xyz/index.html rel=canonical type=text/html title="Overview - Thinging X"><link href=/index.xml rel=alternate type=application/rss+xml title="Overview - Thinging X"><link href=/images/favicon.svg?1704121548 rel=icon type=image/svg+xml><link href=/css/fontawesome-all.min.css?1704121548 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fontawesome-all.min.css?1704121548 rel=stylesheet></noscript><link href=/css/nucleus.css?1704121548 rel=stylesheet><link href=/css/auto-complete.css?1704121548 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/auto-complete.css?1704121548 rel=stylesheet></noscript><link href=/css/perfect-scrollbar.min.css?1704121548 rel=stylesheet><link href=/css/fonts.css?1704121548 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fonts.css?1704121548 rel=stylesheet></noscript><link href=/css/theme.css?1704121548 rel=stylesheet><link href=/css/theme-learn.css?1704121548 rel=stylesheet id=variant-style><link href=/css/variant.css?1704121548 rel=stylesheet><link href=/css/print.css?1704121548 rel=stylesheet media=print><link href=/css/format-print.css?1704121548 rel=stylesheet><link href=/css/ie.css?1704121548 rel=stylesheet><script src=/js/url.js?1704121548></script>
<script src=/js/variant.js?1704121548></script>
<script>window.index_js_url="/index.search.js";var root_url="/",baseUriFull,baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="Copy to clipboard",window.T_Copied_to_clipboard="Copied to clipboard!",window.T_Copy_link_to_clipboard="Copy link to clipboard",window.T_Link_copied_to_clipboard="Copied link to clipboard!",window.T_No_results_found="No results found for \u0022{0}\u0022",window.T_N_results_found="{1} results found for \u0022{0}\u0022",baseUriFull="http://thinkingx.xyz/",window.variants&&variants.init(["learn","relearn-light","relearn-dark","relearn-bright","neon","blue","green","red"])</script></head><body class="mobile-support print" data-url=/index.html><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable><div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle class=topbar-link title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Overview</span><meta itemprop=position content="1"></li></ol></div></div></nav><main id=body-inner class="highlightable home" tabindex=-1><div class=flex-block-wrapper><div id=head-tags></div><article class=home><h1 id=overview>Overview</h1><p>大道至简，简则易行</p><blockquote><ul><li>学习不仅是为了找到答案，更是为了找到方法。</li><li>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</li><li>简单的设计是：设计者确定其设计已经达到了完美的标准不是不能再增加任何东西，而是不能再减少任何东西。 &ndash; 编程珠玑</li><li>程序员的主要问题与其说是技术问题，还不如说是心理问题，他不能解决问题，是因为他在企图解决错误问题，问题的最终解决， 是通过打破他的概念壁垒，进而去解决一个较简单的问题而实现的。 &ndash; 编程珠玑</li><li>如无必要，勿增实体。 &ndash; 奥卡姆剃刀原理</li></ul></blockquote><p>成为一名适应时代变化的软件工程师，知识体系的建设至关重要。</p><h2 id=quick-reference>Quick Reference</h2><ul class="children children-li children-sort-"><li><a href=/basics/index.html>CS</a></li><li><a href=/blockchain/index.html>Blockchain</a></li><li><a href=/distribute-service/index.html>Distribute Service</a></li><li><a href=/programming-language/index.html>Programming Language</a></li></ul><h2 id=how-to-organize>How to organize</h2><p>指导思想是以计算机基础知识为底座，并结合人类在各方面留下的宝贵经验和真理，延伸到更多的应用领域，注重实战。</p><ul><li>基础知识<ul><li>操作系统原理</li><li>网络原理</li><li>计算机组成原理</li></ul></li><li>软件工程<ul><li>编程语言</li><li>设计模式</li><li>架构设计</li><li>代码质量</li><li>代码重构</li><li>代码审查</li><li>代码测试</li><li>代码部署</li><li>代码发布</li><li>代码监控</li><li>代码运维</li></ul></li><li>中间件<ul><li>数据库</li><li>缓存</li><li>消息队列</li><li>搜索引擎</li><li>分布式文件系统</li><li>分布式数据库</li><li>分布式缓存</li><li>分布式消息队列</li><li>分布式搜索引擎</li><li>分布式事务</li><li>分布式锁</li><li>分布式调度</li><li>分布式配置</li><li>分布式日志</li><li>分布式监控</li><li>分布式追踪</li><li>分布式链路</li><li>分布式存储</li><li>分布式计算</li><li>分布式任务</li><li>分布式协调</li></ul></li><li>topic</li><li>行业<ul><li>区块链</li><li>人工智能</li><li>云计算</li></ul></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Overview</h1><article class=chapter><div class=article-subheading>Chapter 1</div><h1 id=cs>CS</h1><p>CS, Computer Science, 计算机科学是系统性研究信息与计算的理论基础以及它们在计算机系统中如何实现与应用的实用技术的学科；涵盖的内容非常多，但是最核心最基础的学科是计算机科学的基石，包括但不限于：</p><ul><li>数据结构与算法</li><li>计算机组成原理（计算机体系结构与计算机工程）</li><li>操作系统</li><li>计算机网络</li><li>分布式系统</li><li>计算机安全和密码学</li><li>数据库</li><li>并行计算和分布式计算</li><li>编译原理</li><li>软件设计</li><li>&mldr;</li></ul><footer class=footline></footer></article><article class=chapter><div class=article-subheading>Chapter 2</div><h1 id=blockchain>Blockchain</h1><p>Blockchain is a distributed ledger technology that allows for the creation of a decentralized network of computers that can store and share information in a secure.</p><p>怎么组织区块链相关的知识呢？</p><ul><li>区块链原理：技术原理、经济模型等，以及常见的主网</li><li>Wallet</li><li>Web3</li><li>热点 (Hot / Trend)<ul><li>BRC20</li></ul></li></ul><ul class="children children-li children-sort-"><li><a href=/blockchain/0-introduction/index.html>区块链概要</a></li><li><a href=/blockchain/bitcoin/index.html>Deep Understanding of Bitcoin</a></li><li><a href=/blockchain/ethereum/index.html>Deep Understanding of Ethereum</a></li><li><a href=/blockchain/wallet/index.html>Wallet</a></li><li><a href=/blockchain/smart-contracts/index.html>Smart Contracts</a></li><li><a href=/blockchain/web3/index.html>Web3</a></li></ul><h2 id=reference>Reference</h2><ul><li><p><a href=https://blockchain-comparison.com/blockchain-protocols/ target=_blank>Blockchain Protocols</a> - We research layer 1 blockchain protocols to provide the most accurate, up-to-date information on all of them and make this the easiest way for you to get to know and use them.</p></li><li><p><a href=https://learnmeabitcoin.com/ target=_blank>How does Bitcoin work?</a> - 这是一个学习 Bitcoin 如何工作的网站，内容非常好</p></li></ul><h3 id=abstract-account>Abstract Account</h3><ul><li><a href=https://blog.jarrodwatts.com/what-is-account-abstraction-and-how-does-eip-4337-work target=_blank>How Account Abstraction Will Change Web3 UX Forever</a></li><li><a href=https://hackernoon.com/what-is-account-abstraction-and-why-is-everyone-talking-about-it target=_blank>What is Account Abstraction and Why is Everyone Talking About It?</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Blockchain</h1><article class=default><h1 id=区块链概要>区块链概要</h1><p>区块链原理</p><ul><li>双花问题</li><li>Markel Tree</li></ul><h2 id=交易模型>交易模型</h2><p>最基础的两个：UTXO 和 账户模型</p><footer class=footline></footer></article><article class=default><h1 id=deep-understanding-of-bitcoin>Deep Understanding of Bitcoin</h1><p>深入学习 Bitcoin 及其工作原理，有几个非常不错的资源值得推荐</p><ol><li><a href=https://github.com/bitcoinbook/bitcoinbook target=_blank>Mastering Bitcoin 2th edition</a></li><li><a href=https://learnmeabitcoin.com/ target=_blank>learn me a bitcoin</a></li></ol><footer class=footline></footer></article><article class=default><h1 id=deep-understanding-of-ethereum>Deep Understanding of Ethereum</h1><h2 id=深入理解以太坊>深入理解以太坊</h2><h3 id=专有名词>专有名词</h3><p>EOA, Contract Accounts, Account state, Account nonce, World state, Transaction, Receipt, Block, Uncle block, Nonce, Gas, Gas price, Gas Price Oracle</p><p>Zero Knowledge Proof, EVM, Message, RLP, MPT (Merkle Patricia Tree), Patricia Trie, Merkle Tree, Whisper, Light Ethereum Subprotocol, Swarm, LLL, Sperpent, Mutan, Solidity, EIPs(ERC20, ERC721)</p><p><strong>Uncle block</strong></p><blockquote><p>Uncle blocks (or Ommer) are created when two or more miners create blocks at nearly the same time. Only one block can be mined and accepted as canonical on the blockchain. The others are uncle blocks, which are not included but still provide a reward to their miners for the work done.</p><p>在比特币网络中，uncle block 是没有奖励的；但在以太坊网络中，uncle block 有奖励，并且一个区块最多能引用 2 个 uncle block;</p><ol><li>uncle block reward 是奖励给 uncle block 的矿工的，前提是被确认的区块引用了这个 uncle block</li><li>包含了 uncle block 的区块，会获得一个额外的奖励，这个奖励是 uncle block reward 的 1/32
主要作用是：提高网络安全性，提高矿工的积极性</li></ol></blockquote><ol><li><a href=https://www.hellobtc.com/kp/kc/201904/1562.html target=_blank>以太坊为什么要设置区块的叔块奖励？</a></li><li><a href=https://medium.com/@ShariHunt/there-are-two-uncle-rewards-a67e06fa17de target=_blank>There are two uncle rewards</a></li></ol><p>在以太坊升级 PoS 后，uncle block 还有吗？</p><ol><li><a href=https://ethereum.stackexchange.com/questions/8571/block-header-structure-change-under-the-merge-to-proof-of-stake/129809#129809 target=_blank>Block header structure change under the Merge to Proof of Stake?</a></li><li><a href=https://blog.ethereum.org/2021/11/29/how-the-merge-impacts-app-layer target=_blank>How The Merge Impacts Ethereum’s Application Layer</a></li></ol><p>总结下来，以太坊从 PoW 升级到 PoS 后，部分和 PoW 共识相关的字段就无用了，但是出于兼容和一致性的考虑，这些字段会被设置默认值，其中 uncle (Ommer) 是其中一项。</p><blockquote><p>In order to minimize disruption to tooling and infrastructure, these fields are set to 0, or their data structure&rsquo;s equivalent, rather than being entirely removed from the data structure. The full changes to block fields can be found in <a href=https://eips.ethereum.org/EIPS/eip-3675#block-structure target=_blank>EIP-3675</a>.</p></blockquote><h3 id=账户模型>账户模型</h3><p>以太坊中，账户分为：外部账户（EOAs）和合约账户（contract account）</p><p>参考</p><ol><li><a href=https://learnblockchain.cn/books/geth/part1/account.html target=_blank>账户</a></li></ol><h4 id=eoas>EOAs</h4><p>EOAs-外部账户(external owned accouts)是由人们通过私钥创建的账户。 是真实世界的金融账户的映射，拥有该账户私钥的任何人都可以控制该账户。 如同银行卡，到ATM机取款时只需要密码输入正确即可交易。 这也是人类与以太坊账本沟通的唯一媒介，因为以太坊中的交易需要签名， 而只能使用拥有私有外部账户签名。</p><p>外部账户特点总结：</p><ol><li>拥有以太余额。</li><li>能发送交易，包括转账和执行合约代码。</li><li>被私钥控制。</li><li>没有相关的可执行代码。</li></ol><h4 id=合约账户>合约账户</h4><p>含有合约代码的账户。 被外部账户或者合约创建，合约在创建时被自动分配到一个账户地址， 用于存储合约代码以及合约部署或执行过程中产生的存储数据。 合约账户地址是通过SHA3哈希算法产生，而非私钥。 因无私钥，因此无人可以拿合约账户当做外部账户使用。 只能通过外部账户来驱动合约执行合约代码。</p><pre tabindex=0><code>// 合约地址生成算法
// sender: 指交易的发起者的地址
// nonce: 指该交易的随机数
Keccak256(rlp([sender,nonce])[12:])
</code></pre><p>合约账户特点总结：</p><ol><li>拥有以太余额。</li><li>有相关的可执行代码（合约代码）。</li><li>合约代码能够被交易或者其他合约消息调用。</li><li>合约代码被执行时可再调用其他合约代码。</li><li>合约代码被执行时可执行复杂运算，可永久地改变合约内部的数据存储。</li></ol><h4 id=账户抽象>账户抽象</h4><p>在最近的 EIP 中提出了账户抽象的概念(关于账户抽象看 <a href=https://ethereum.org/en/roadmap/account-abstraction/ target=_blank>Account abstraction</a>)</p><h4 id=账户数据结构>账户数据结构</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Account</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Nonce</span>    <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Balance</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>big</span>.<span style=color:#a6e22e>Int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Root</span>     <span style=color:#a6e22e>common</span>.<span style=color:#a6e22e>Hash</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CodeHash</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=#image-10f74cb515b92adfe38e1efaae550553 class=lightbox-link><img src="/images/ethereum-account.png?classes=shadow&amp;width=500px" alt="Account Model" class=shadow style=height:auto;width:500px loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-10f74cb515b92adfe38e1efaae550553><img src="/images/ethereum-account.png?classes=shadow&amp;width=500px" alt="Account Model" class=lightbox-image loading=lazy></a></p><h3 id=以太坊中的交易>以太坊中的交易</h3><blockquote><p>指由一个外部账户转移一定资产给某个账户， 或者发出一个消息指令到某个智能合约</p></blockquote><p>参考资料</p><ol><li><a href=https://learnblockchain.cn/books/geth/part1/transaction.html target=_blank>以太坊技术与实现 - 交易</a></li><li>区块链架构之美 - EVM / Transaction</li><li><a href=https://gist.github.com/stonegao/16b8a30d98c4723f04f8259b7eda5da8 target=_blank>深入理解以太坊</a></li></ol><h3 id=ethereum-node-architecture>Ethereum Node Architecture</h3><p>在 The Merge 之后，以太坊节点有两部分组成：执行客户端 (EL, Execution Client) 和共识客户端 (CL, Consensus Client):</p><ul><li>EL 负责交易处理，交易广播，状态管理以及对 EVM 的支持<ul><li>Geth 是一种 EL 的实现，还有其他的实现，比如 Parity</li></ul></li><li>CL 负责区块创建，区块广播和共识逻辑<ul><li><a href=https://ethereum.org/en/developers/docs/nodes-and-clients/#consensus-clients target=_blank>这里可以找到有哪些共识客户端</a></li><li>共识客户端可以变为 Validator，前提是需要像 deposit contract 存入 32 ETH</li></ul></li><li>EL 和 CL 之间的通信使用的是 Engine API, 基于本地的 JSON-RPC<ul><li>CL 是在 <code>The Merge</code> 之后开始生效的，正式从 PoW 切换到 PoS</li></ul></li></ul><p>他们之间的关系如下图</p><p><a href=#image-94ff23b0f61f5e86ebc5e74b9201db26 class=lightbox-link><img src="/images/node-architecture-text-background.png?classes=shadow&amp;width=500px" alt class=shadow style=height:auto;width:500px loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-94ff23b0f61f5e86ebc5e74b9201db26><img src="/images/node-architecture-text-background.png?classes=shadow&amp;width=500px" alt class=lightbox-image loading=lazy></a></p><p>几个规范需要关注</p><ol><li><a href=https://github.com/ethereum/execution-apis target=_blank>Execution API</a></li><li><a href=https://github.com/ethereum/execution-specs target=_blank>Execution Specs</a></li><li><a href=https://github.com/ethereum/execution-apis/tree/main/src/engine target=_blank>Engine API</a></li><li><a href=https://github.com/ethereum/consensus-specs/tree/dev/specs/bellatrix target=_blank>Consensus Specs</a></li></ol><h2 id=evm>EVM</h2><ul><li><a href=https://medium.com/mycrypto/the-ethereum-virtual-machine-how-does-it-work-9abac2b7c9e target=_blank>The Ethereum Virtual Machine — How does it work?</a> - 深入浅出的介绍了 EVM 的工作原理</li></ul><h3 id=event-logs>Event logs</h3><ul><li><a href=https://medium.com/mycrypto/understanding-event-logs-on-the-ethereum-blockchain-f4ae7ba50378 target=_blank>Understanding event logs on the Ethereum blockchain</a></li><li><a href=https://docs.alchemy.com/docs/deep-dive-into-eth_getlogs target=_blank>Understanding Logs: Deep Dive into eth_getLogs</a></li></ul><p>TODO</p><ol><li><a href=https://ethereum.org/en/developers/docs/evm/ target=_blank>https://ethereum.org/en/developers/docs/evm/</a></li></ol><h3 id=storage-layouts-in-evm>Storage Layouts in EVM</h3><p>深入理解 EVM 的存储布局非常重要，因为它直接影响到合约的 gas 消耗，以及合约的安全性。</p><ul><li><a href=https://docs.alchemy.com/docs/smart-contract-storage-layout target=_blank>What is smart contract storage layout ?</a></li></ul><p>Solidity 中有三种内存类型：storage, memory, calldata</p><ol><li>memory 类型的变量和参数，用在函数的内部，只在函数执行期间存在，函数执行完毕后，内存被清空</li><li>calldata 类型是在外部调用函数时，传递的参数，只读，不能修改</li><li>storage 类型的变量，用来存储合约的状态，永久存在，直到合约被销毁</li></ol><p>storage memory layout</p><p>每个合约都有自己的存储区域，它是一个可以持久化、读写的内存区域，合约只能访问自己的内存空间，不能访问其他合约的；合约的存储空间被划分为一个个的存储槽，每个槽的大小为 256 位，每个槽都有一个唯一的索引，从 0 开始，每个槽都可以存储一个 256 位的值，也就是说，每个槽都可以存储一个 uint256 类型的值，或者 32 个字节的值；并且 EVM 一次需要直接访问 32 字节的数据，槽的总数是 2^256 大小。</p><p>这个抽象非常类似虚拟内存，EVM 会记录每个合约中槽的使用情况，最开始槽是没有初始化的</p><p>字节序：大端和小端；在 EVM 中 bytes 和 string 使用的是大端；其他类型用的是小端</p><ol><li>如果一个类型不足 32 bytes，会被填充到 32 bytes；但是填充会浪费内存空间，但是带来了 gas 的节约，因为读写成本更低</li><li>但是在某些情况下，会把紧邻的不足 32 bytes 的变量包装在一起，可以节省内存空间，但是会增加 gas 消耗，因为读写成本更高，需要做更多的位运算</li></ol><h2 id=references>References</h2><ul><li><a href=https://gist.github.com/stonegao/16b8a30d98c4723f04f8259b7eda5da8 target=_blank>深入理解以太坊</a> - 简要介绍以太坊的架构</li><li><a href=https://learnblockchain.cn/books/geth/ target=_blank>以太坊设计与实现</a> - 一本深入探讨以太坊实现的电子书</li><li><a href=https://geth.ethereum.org/ target=_blank>go-ethereum doc</a> - geth 的官方文档</li><li><a href=https://blog.ethereum.org/ target=_blank>Ethereum Blog</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Deep Understanding of Ethereum</h1><article class=default><h1 id=构建以太坊网络>构建以太坊网络</h1><h2 id=测试网络>测试网络</h2><ul><li><a href=https://goerli.net/ target=_blank>Goerli Testnet</a><ul><li><a href=https://github.com/eth-clients/goerli target=_blank>Goerli (Goerlitzer Testnet)</a></li><li><a href=https://goerli.etherscan.io/ target=_blank>Goerli Testnet Explorer</a></li><li><a href=https://goerli.beaconcha.in/ target=_blank>Görli beacon Testnet</a></li></ul></li></ul><h2 id=搭建私有以太坊私有网络>搭建私有以太坊私有网络</h2><p>搭建私有网络</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 1. Clone go-ethereum</span>
</span></span><span style=display:flex><span>git clone https://github.com/ethereum/go-ethereum.git
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. Build go-ethereum, make sure you have installed go, version &gt;= 1.19</span>
</span></span><span style=display:flex><span>cd go-ethereum <span style=color:#f92672>&amp;&amp;</span> make all
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. Copy geth to $GOPATH/bin</span>
</span></span><span style=display:flex><span>cp build/bin/geth $GOPATH/bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. Create private network with two nodes</span>
</span></span><span style=display:flex><span>cd $HOME/priveth <span style=color:#f92672>&amp;&amp;</span> mkdir node1 node2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 4. Create accounts</span>
</span></span><span style=display:flex><span><span style=color:#75715e># On node1</span>
</span></span><span style=display:flex><span>geth --datadir $HOME/priveth/node1 account new
</span></span><span style=display:flex><span><span style=color:#75715e># Password: foobar</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Account1 -&gt; Public address of the key:   0x46eE6c1779eB3421Fc355132D867804894eFB1F9</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Account2 -&gt; Public address of the key:   0x4B3Beee7E6E067080f71336fF118E76E53C63cA3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Signer address -&gt; 0x3D43ed16b178611C0aBA87a00Dd6b2655aa89287</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># On node2</span>
</span></span><span style=display:flex><span>geth --datadir $HOME/priveth/node2 account new
</span></span><span style=display:flex><span><span style=color:#75715e># Public address of the key:   0x69b24ce645c0Bbdfcc0FE4297804b82F888DE8Fe</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 5. Create genesis config</span>
</span></span><span style=display:flex><span>geth --datadir $HOME/priveth/node1 init genesis.json
</span></span><span style=display:flex><span>geth --datadir $HOME/priveth/node2 init genesis.json
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 6. Start bootnode, 在其中一个 node 启动即可</span>
</span></span><span style=display:flex><span>bootnode -genkey boot.key
</span></span><span style=display:flex><span>bootnode -nodekey boot.key -addr :30305
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 6. Start </span>
</span></span><span style=display:flex><span><span style=color:#75715e># Start node1, locate to $HOME/priveth</span>
</span></span><span style=display:flex><span>geth --datadir node1 --port <span style=color:#ae81ff>30306</span> --bootnodes <span style=color:#e6db74>&#39;enode://3988b0cf1d24581e50d1a888e0c9588b1f7403477cf621f46c7add34b2bf786865601c4b6a07924e5f1eed250214192355b5ea5571e5887055e464ccb91dce3e@127.0.0.1:0?discport=30305&#39;</span> --networkid <span style=color:#ae81ff>12345</span> --unlock 0x3D43ed16b178611C0aBA87a00Dd6b2655aa89287 --password node1/walletpwd.txt --authrpc.port <span style=color:#ae81ff>8551</span> --http.vhosts<span style=color:#f92672>=</span>*
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Start node2</span>
</span></span><span style=display:flex><span>geth --datadir node2 --port <span style=color:#ae81ff>30307</span> --bootnodes <span style=color:#e6db74>&#39;enode://3988b0cf1d24581e50d1a888e0c9588b1f7403477cf621f46c7add34b2bf786865601c4b6a07924e5f1eed250214192355b5ea5571e5887055e464ccb91dce3e@127.0.0.1:0?discport=30305&#39;</span> --networkid <span style=color:#ae81ff>12345</span> --unlock 0x69b24ce645c0Bbdfcc0FE4297804b82F888DE8Fe --password node2/walletpwd.txt --authrpc.port <span style=color:#ae81ff>8552</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Attach</span>
</span></span><span style=display:flex><span>geth attach node1/geth.ipc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>curl --data <span style=color:#e6db74>&#39;{&#34;jsonrpc&#34;:&#34;2.0&#34;,&#34;method&#34;:&#34;eth_getBalance&#34;, &#34;params&#34;: [&#34;0x3D43ed16b178611C0aBA87a00Dd6b2655aa89287&#34;, &#34;latest&#34;], &#34;id&#34;:2}&#39;</span> -H <span style=color:#e6db74>&#34;Content-Type: application/json&#34;</span> localhost:8551
</span></span></code></pre></div><p><code>genesis.json</code> content</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;config&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;chainId&#34;</span>: <span style=color:#ae81ff>12345</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;homesteadBlock&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;eip150Block&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;eip155Block&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;eip158Block&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;byzantiumBlock&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;constantinopleBlock&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;petersburgBlock&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;istanbulBlock&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;muirGlacierBlock&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;berlinBlock&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;londonBlock&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;arrowGlacierBlock&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;grayGlacierBlock&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;clique&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;period&#34;</span>: <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;epoch&#34;</span>: <span style=color:#ae81ff>30000</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;difficulty&#34;</span>: <span style=color:#e6db74>&#34;1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;gasLimit&#34;</span>: <span style=color:#e6db74>&#34;800000000&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;extradata&#34;</span>: <span style=color:#e6db74>&#34;0x00000000000000000000000000000000000000000000000000000000000000003D43ed16b178611C0aBA87a00Dd6b2655aa892870000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;alloc&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;3D43ed16b178611C0aBA87a00Dd6b2655aa89287&#34;</span>: { <span style=color:#f92672>&#34;balance&#34;</span>: <span style=color:#e6db74>&#34;500000&#34;</span> },
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;69b24ce645c0Bbdfcc0FE4297804b82F888DE8Fe&#34;</span>: { <span style=color:#f92672>&#34;balance&#34;</span>: <span style=color:#e6db74>&#34;500000&#34;</span> },
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;46eE6c1779eB3421Fc355132D867804894eFB1F9&#34;</span>: { <span style=color:#f92672>&#34;balance&#34;</span>: <span style=color:#e6db74>&#34;300000&#34;</span> },
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;4B3Beee7E6E067080f71336fF118E76E53C63cA3&#34;</span>: { <span style=color:#f92672>&#34;balance&#34;</span>: <span style=color:#e6db74>&#34;200000&#34;</span> }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看这个官方教程来理解更多关于私有网络的搭建: <a href=https://geth.ethereum.org/docs/fundamentals/private-network target=_blank>Private network</a></p><footer class=footline></footer></article></section><article class=default><h1 id=wallet>Wallet</h1><p>作为用户，Wallet 是区块链的入口；现阶段主流的 Wallet 类型有：HD Wallet，MultiSig wallet，Custodial wallet，Hardware wallet，Paper wallet，MPC Wallet 等。作为开发者，HD Wallet、MultiSig Wallet、MPC Wallet 是需要重点掌握的。</p><h2 id=hd-wallet>HD wallet</h2><p>钱包是用来存钱的，在区块链中，我们的数字资产都会对应到一个账户地址上， 只有拥有账户的钥匙（私钥）才可以对资产进行消费（用私钥对消费交易签名）。</p><p>他们之间的关系如下：</p><p><a href=#image-387fe55c886d7a921b2acfd603fd794f class=lightbox-link><img src="/images/blockchain/priv-pub-address-rel.png?classes=shadow" alt=wallet class=shadow style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-387fe55c886d7a921b2acfd603fd794f><img src="/images/blockchain/priv-pub-address-rel.png?classes=shadow" alt=wallet class=lightbox-image loading=lazy></a></p><p>私钥通过椭圆曲线生成公钥， 公钥通过哈希函数生成地址，这两个过程都是单向的; 所以，数字钱包实际是一个管理私钥（生成、存储、签名）的工具，注意钱包并不保存资产，资产是在链上的。</p><blockquote><p>生成私钥的本质是在 1 到 2^256 之间选一个数字：生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源，只要选取的结果是不可预测或不可重复的</p></blockquote><p>HD, Hierarchical Deterministic, 叫做分层确定性钱包，是一种可以从单个种子（seed）衍生出一系列私钥的钱包结构，这些私钥都可以被根种子所控制，这样就可以用一个种子来管理多个账户。</p><p>在 Mastering Bitcoin 中，有一章是来介绍 Wallet 的，有必要看一下：<a href=https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch05.asciidoc target=_blank>Mastering Bitcoin - Wallet</a>, <a href="https://drive.google.com/file/d/16mdtupaXPfJOyFS8YBzJ4O25HfD00Pg9/view?usp=sharing" target=_blank>中文版看这里</a></p><p>HD 钱包允许我们使用一个密钥管理很多个衍生私钥，进而控制多个地址，bip32 规范中使用一种树形结构来进行管理。</p><p><a href=#image-279bdd7f6e00bb8c68a0ba749690f22b class=lightbox-link><img src="/images/blockchain/hd_01.png?classes=shadow&amp;height=400px" alt="HD Bip32" class=shadow style=height:400px;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-279bdd7f6e00bb8c68a0ba749690f22b><img src="/images/blockchain/hd_01.png?classes=shadow&amp;height=400px" alt="HD Bip32" class=lightbox-image loading=lazy></a></p><p>关于 HD wallet 有一系列规范：</p><ul><li><a href=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki target=_blank>bip32</a></li><li><a href=https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki target=_blank>bip44</a></li><li><a href=https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki target=_blank>bip39</a></li><li><a href=https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki target=_blank>bip43</a></li></ul><h3 id=bip39>bip39</h3><p>bip39 规范主要关于生成确定性密钥的助记码，使用一组预定义的单词来表示一串随机数，这样就可以方便的记忆和传输。主要包含两部分：生成助记码和从主机码转成二进制私钥种子。</p><p>我们来看看 bip39 的技术细节</p><p><strong>如何生成助机词</strong></p><ol><li>Create a random sequence (entropy) of 128 to 256 bits.</li><li>Create a checksum of the random sequence by taking the first (entropy-length/32) bits of its SHA256 hash.</li><li>Add the checksum to the end of the random sequence.</li><li>Split the result into 11-bit length segments.</li><li>Map each 11-bit value to a word from the predefined dictionary of 2048 words.</li><li>The mnemonic code is the sequence of words.</li></ol><p><a href=#image-0d942fe159e9d651aefccc07a658f0c2 class=lightbox-link><img src="/images/blockchain/bip39-1.png?classes=shadow&amp;height=400px" alt class=shadow style=height:400px;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-0d942fe159e9d651aefccc07a658f0c2><img src="/images/blockchain/bip39-1.png?classes=shadow&amp;height=400px" alt class=lightbox-image loading=lazy></a></p><p>随机熵和单词长度的关系：</p><table><thead><tr><th>Entropy (bits)</th><th>Checksum (bits)</th><th>Entropy + checksum (bits)</th><th>Mnemonic length (words)</th></tr></thead><tbody><tr><td>128</td><td>4</td><td>132</td><td>12</td></tr><tr><td>160</td><td>5</td><td>165</td><td>15</td></tr><tr><td>192</td><td>6</td><td>198</td><td>18</td></tr><tr><td>224</td><td>7</td><td>231</td><td>21</td></tr><tr><td>256</td><td>8</td><td>264</td><td>24</td></tr></tbody></table><p><strong>用助记词生成种子</strong></p><ol><li>The first parameter to the PBKDF2 key-stretching function is the mnemonic produced from step 6.</li><li>The second parameter to the PBKDF2 key-stretching function is a salt. The salt is composed of the string constant &ldquo;mnemonic&rdquo; concatenated with an optional user-supplied passphrase string.</li><li>PBKDF2 stretches the mnemonic and salt parameters using 2048 rounds of hashing with the HMAC-SHA512 algorithm, producing a 512-bit value as its final output. That 512-bit value is the seed.</li></ol><p><a href=#image-2fbd7cb11354b0841d790413e056f2f5 class=lightbox-link><img src="/images/blockchain/bip39-2.png?classes=shadow&amp;height=400px" alt class=shadow style=height:400px;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-2fbd7cb11354b0841d790413e056f2f5><img src="/images/blockchain/bip39-2.png?classes=shadow&amp;height=400px" alt class=lightbox-image loading=lazy></a></p><p>参考实现：</p><ul><li><a href=https://github.com/tyler-smith/go-bip39 target=_blank>go 版本的 bip39 实现</a></li></ul><p>源码解析</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewEntropy</span>(<span style=color:#a6e22e>bitSize</span> <span style=color:#66d9ef>int</span>) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 验证位数在 128 到 256 之间，并且是 32 的倍数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>validateEntropyBitSize</span>(<span style=color:#a6e22e>bitSize</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>entropy</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>bitSize</span><span style=color:#f92672>/</span><span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 这里使用的是 crypto/rand 包，而不是 math/rand 包，因为 math/rand 包是伪随机数生成器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 这里显然需要一个真随机数生成器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>entropy</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>entropy</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 用法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>entropy</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bip39</span>.<span style=color:#a6e22e>NewEntropy</span>(<span style=color:#ae81ff>256</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>mnemonic</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bip39</span>.<span style=color:#a6e22e>NewMnemonic</span>(<span style=color:#a6e22e>entropy</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>seed</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bip39</span>.<span style=color:#a6e22e>NewSeed</span>(<span style=color:#a6e22e>mnemonic</span>, <span style=color:#e6db74>&#34;hello&#34;</span>)
</span></span></code></pre></div><p>总结一下：bip39 的主要作用就是把随机生成的 seed 转成助记词，方便记忆、传输等，不管是导入、导出还是备份都非常方便，并且从助记词也可以还原出 seed。</p><h3 id=bip32--bip44>bip32 & bip44</h3><p><strong>从种子生成钱包</strong></p><p>上面了解了 bip39，通过 bip39 我们可以获取一个助记词序列，它本质上是一个随机数，这个随机数被用来当作 seed 来生成私钥。bip32 规范主要是定义了从 seed 生成私钥的过程，它定义了一种树形结构来管理私钥，这种树形结构的每个节点都有一个索引，这个索引可以用来生成子节点，这样就可以方便的管理多个私钥。</p><p><a href=#image-a76165b3df2dcece9e4b1fb2abff8334 class=lightbox-link><img src="/images/blockchain/bip44-1.webp?classes=shadow" alt class=shadow style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-a76165b3df2dcece9e4b1fb2abff8334><img src="/images/blockchain/bip44-1.webp?classes=shadow" alt class=lightbox-image loading=lazy></a></p><p>关于 extended key 也可以看这里：<a href=https://learnmeabitcoin.com/technical/extended-keys target=_blank>extended keys</a></p><p>参考实现</p><ul><li><a href=https://github.com/btcsuite/btcd/tree/master/btcutil/hdkeychain target=_blank>go 版本的 hdkeychain</a> - 里面包含对 extended key 的实现，也就是实现了 bip32 规范</li></ul><h3 id=keys-和-addresses>Keys 和 Addresses</h3><p>在上面介绍的几个 bip 规范中，其实少了一些细节，比如私钥如何生成公钥？公钥如何生成地址？不同的链使用的算法都一样吗？&mldr;</p><p>关于这些问题可以参考这篇文章：<a href=https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc target=_blank>Mastering Bitcoin - Keys and Addresses</a></p><table><thead><tr><th>Chain</th><th>Private Key -> Public Key</th><th>Compressed Public Key ?</th><th>Public Key -> Address</th><th>Address Format</th></tr></thead><tbody><tr><td>BTC</td><td>ECDSA (ecc Secp256k1)</td><td>Yes</td><td>SHA256 + RIPEMD160</td><td>Base58</td></tr><tr><td>ETH</td><td>ECDSA (ecc Secp256k1)</td><td>Yes</td><td>Keccak256</td><td>Hex</td></tr><tr><td>BNB</td><td>ECDSA (ecc Secp256k1)</td><td>Yes</td><td>Keccak256</td><td>Bech32</td></tr></tbody></table><p>对于地址生成算法，不同的链不太一样</p><ul><li>Bitcoin 采用 SHA256 + RIPEMD160, 然后再进行 Base58 编码</li><li>Ethereum 采用 Keccak256, 然后再进行 Hex 编码<ul><li>对公钥做 Keccak-256 哈希运算，然后取最后的 40 位 16 进制字符</li></ul></li></ul><h2 id=实现一个支持多链的-hd-本地钱包>实现一个支持多链的 HD 本地钱包</h2><p>一些想法</p><ul><li>这个本地钱包，我们暂时叫他 hdkms，后面都这么叫</li><li>hdkms 支持管理多个钱包，可以通过指定 name 来区分不同的 hd wallet<ul><li>wallet1 -> mnemonic -> seed -> master private key -> local keystore file1</li><li>wallet2 -> mnemonic -> seed -> master private key -> local keystore file2</li></ul></li><li>hdkms 支持导入助记词、私钥</li><li>hdkms 支持导出助记词、私钥</li><li>hdkms 支持生成地址，并且可以指定 index</li><li>hdkms 可以查看 address 的余额</li><li>hdkms 支持多链<ul><li>比如 Bitcoin, Ethereum, Binance Smart Chain etc.</li></ul></li><li>hdkms 可以离线签署交易，生成签名后的交易数据<ul><li>支持 native token 的 transfer</li><li>支持 erc20</li><li>支持 NFT</li><li>支持任意类型的合约</li></ul></li><li>hdkms 可以在线广播交易<ul><li>broadcast tx</li><li>查询 tx 状态</li></ul></li><li>hdkms 一些高级功能<ul><li>支持 event 监听</li><li>支持动态手续费，比如 gas fee，network fee 等</li><li>&mldr;</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 考虑怎么使用</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  1. 提供命令行工具，比如 hd-kms </span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建钱包</span>
</span></span><span style=display:flex><span>hdkms wallet generate --wallet-name test1 --passphase <span style=color:#ae81ff>123456</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hdkms wallet import --wallet-name test1 --mnemonic <span style=color:#e6db74>&#34;&#34;</span> --passphase <span style=color:#ae81ff>123456</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ hdkms wallet export --wallet-name test1
</span></span><span style=display:flex><span>$ <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;mnemonic&#34;</span>: <span style=color:#e6db74>&#34;xxx&#34;</span>, <span style=color:#e6db74>&#34;passphase&#34;</span>: <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>TODOs</p><ul><li><input checked disabled type=checkbox> 搭建起项目的基本框架<ul><li><input checked disabled type=checkbox> 搞定 cli 及其扩展子命令</li><li><input checked disabled type=checkbox> 支持多个子命令的调用，比如 hdkms wallet generate, hdkms wallet list &mldr;</li></ul></li><li><input disabled type=checkbox> 支持 Ethereum<ul><li><input disabled type=checkbox> generate wallet</li><li><input disabled type=checkbox> mnemonic</li><li><input disabled type=checkbox> store mnemonic or private key to local keystore file</li><li><input disabled type=checkbox> get address by index</li><li><input disabled type=checkbox> query balance by address</li></ul></li></ul><footer class=footline></footer></article><article class=default><h1 id=smart-contracts>Smart Contracts</h1><p>这里主要是关于智能合约。</p><ol><li>搞明白 hardhat</li><li>用 hardhat 和 openzeplin 写 erc20 合约，部署、运行等</li></ol><h2 id=开发工具框架>开发工具、框架</h2><blockquote><p>工欲善其事，必先利其器。</p></blockquote><h3 id=开发工具>开发工具</h3><ul><li><p><a href=https://remix.ethereum.org/ target=_blank>Remix</a> - 一个基于浏览器的 IDE，可以用来编写、编译、部署智能合约。</p><ul><li>Remix 内部也提供了一个交互式的学习 Solidity 的教程</li></ul></li><li><p>Visiual Studio Code & Solidity Extension - 一个 VSCode 的插件，可以用来编写、编译、部署智能合约。</p></li><li><p>Jetbrains 系列 IDE & Solidity Extension - 一个 Jetbrains 系列 IDE 的插件，可以用来编写、编译、部署智能合约。</p></li></ul><h3 id=开发框架>开发框架</h3><ul><li>Hardhat</li><li>OpenZeplin</li><li>Truffle</li><li><a href=https://docs.ethers.org/v6/ target=_blank>ether.js</a></li><li>Ganache</li><li>TypeScript & JavaScript & ES6 & Node.js</li></ul><h3 id=学习资源>学习资源</h3><ul><li><p>Solidity Documents</p><ul><li><a href=https://solidity-cn.readthedocs.io/zh/develop/introduction-to-smart-contracts.html target=_blank>中文版</a></li><li><a href=https://docs.soliditylang.org/en/v0.8.17/ target=_blank>英文版</a></li></ul></li><li><p><a href=https://www.wtf.academy/learning-center target=_blank>WTF 学院</a></p><ul><li><a href=https://github.com/AmazingAng/WTF-Solidity target=_blank>WTF-Solidity</a></li></ul></li><li><p><a href=https://goethereumbook.org/zh/ target=_blank>用 Go 来做以太坊开发</a> & <a href=https://goethereumbook.org/en/ target=_blank>Ethereum Development with Go</a></p></li><li><p><a href=https://github.com/33357/smartcontract-apps target=_blank>smartcontract-apps</a> - 分析市面上智能合约应用的架构与实现的仓库</p></li><li><p><a href=https://twitter.com/0xAA_Science target=_blank>0xAA</a></p></li><li><p><a href=https://twitter.com/SlowMist_Team target=_blank>SlowMist</a></p></li><li><p><a href=https://twitter.com/Dapp_Learning target=_blank>Dapp_Learning</a></p></li><li><p><a href=https://twitter.com/VitalikButerin target=_blank>Vitalik</a></p></li><li><p><a href=https://learnblockchain.cn target=_blank>登链</a></p></li><li><p><a href=https://t.me/scientistDAO target=_blank>科学家社区</a></p></li><li><p><a href=https://space.bilibili.com/286084162 target=_blank>崔棉大师</a></p></li></ul><h2 id=语法>语法</h2><h3 id=变量数据类型和可见性>变量，数据类型和可见性</h3><p>Solidity 有三种变量类型：</p><ul><li>状态变量</li><li>本地变量</li><li><a href=https://docs.soliditylang.org/en/v0.8.17/units-and-global-variables.html target=_blank>全局变量</a></li></ul><p>在 Solidity 的全局命名空间中，存在一些特殊的变量，可以在任何地方访问，不需要声明；主要提供一些区块链信息和通用的处理函数。</p><ol><li>区块和交易相关：<code>block.basefee</code>, <code>msg.sender</code>, <code>msg.data</code> (calldata), <code>msg.value</code>, <code>msg.sig</code>, <code>tx.gasprice</code>, <code>tx.origin</code>, <code>block.gaslimit</code>, <code>block.number</code>, <code>block.timestamp</code>, <code>block.difficulty</code>, <code>block.coinbase</code>, <code>block.chainid</code>, <code>blockhash(uint blockNumber) returns (bytes32)</code>, <code>gasleft() returns (uint256)</code></li><li>abi 编解码函数</li><li>错误处理：<code>assert</code>, <code>require</code>, <code>revert</code></li><li>数学和加密函数：<code>keccak256</code>, <code>sha256</code>, <code>ripemd160</code>, <code>ecrecover</code>, <code>addmod</code>, <code>mulmod</code> 等等</li><li>地址类型：<code>&lt;address>.balance</code>, <code>&lt;address>.code</code> 等等</li><li>合约相关：<code>this</code>, <code>selfdestruct(address recipient)</code></li></ol><h3 id=storage-memory-calldata>storage, memory, calldata</h3><p>Solidity 中有几种变量的存储类型</p><ol><li>memory: 一些被临时使用的变量，比如函数参数、本地变量、在执行过程中动态创建的数组；一旦函数执行完毕，这些变量就会被销毁。</li><li>storage</li><li>calldata</li></ol><ul><li><a href=https://docs.alchemy.com/docs/what-is-the-difference-between-memory-and-calldata-in-solidity target=_blank>What is the difference between Memory and Calldata in Solidity?</a></li><li><a href=https://docs.alchemy.com/docs/when-to-use-storage-vs-memory-vs-calldata-in-solidity target=_blank>When to use Storage vs. Memory vs. Calldata in Solidity</a></li></ul><h3 id=函数-function>函数 (function)</h3><h3 id=payable-function>Payable function</h3><ul><li><a href=https://docs.alchemy.com/docs/solidity-payable-functions target=_blank>What are Payable Functions in Solidity?</a></li></ul><h2 id=合约安全>合约安全</h2><h2 id=eip>EIP</h2><h3 id=erc20>ERC20</h3><p>我们首先需要熟悉 ERC20 标准协议，可以看 <a href=https://eips.ethereum.org/EIPS/eip-20 target=_blank>ERC20 Token Standard</a>，非常重要。ERC20 标准规范可以获得更好的重用性，无论是对 web3 应用还是交易所。</p><p>接着可以了解 ERC20 的标准实现，可以看 <a href=https://docs.openzeppelin.com/contracts/3.x/api/token/erc20 target=_blank>OpenZeplin Contracts - ERC20</a> 部分，<a href=https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol target=_blank>代码在这里</a></p><footer class=footline></footer></article><article class=default><h1 id=web3>Web3</h1><p>有理由相信 Web3.0 是下一代的价值互联网。</p><p><a href=#image-60d235a38a5c0f7399661813ea792d65 class=lightbox-link><img src="/images/web3-architecture.png?classes=shadow" alt="Web3 Architecture" class=shadow style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-60d235a38a5c0f7399661813ea792d65><img src="/images/web3-architecture.png?classes=shadow" alt="Web3 Architecture" class=lightbox-image loading=lazy></a></p><ul class="children children-li children-sort-"><li><a href=/blockchain/web3/infra/index.html>Web3 基础设施及工具</a></li></ul><h2 id=references>References</h2><p>这里列出了一些 Web3.0 的相关资料，以供参考。</p><ul><li><p><a href=https://www.preethikasireddy.com/post/the-architecture-of-a-web-3-0-application target=_blank>The Architecture of a Web 3.0 application</a> - 主要介绍相对于 web2.0，web3.0 的架构是怎样的。</p></li><li><p><a href=https://medium.com/toruslabs/a-beginners-guide-the-basic-web3-architecture-and-tech-stack-81f2061d263c target=_blank>Web3 Architecture and Tech Stack : A Beginners Guide</a></p></li><li><p><a href=https://www.coinbase.com/learn/market-updates/around-the-block-issue-22 target=_blank>A simple guide to the Web3 stack</a></p></li><li><p><a href=https://www.coinbase.com/blog/a-simple-guide-to-the-web3-developer-stack target=_blank>A simple guide to the web3 developer stack</a></p></li><li><p><a href=https://scalans.com/a-closer-look-into-the-web-3-architecture target=_blank>What Goes Behind Web 3.0 Architecture?</a></p></li><li><p><a href=https://medium.com/1kxnetwork/application-specific-blockchains-9a36511c832 target=_blank>Application-Specific Blockchains: The Past, Present, and Future</a> - 介绍</p></li></ul><h3 id=项目>项目</h3><ul><li><a href=https://tokenlon.im/ target=_blank>tokenlon</a> - 值得信赖的去中心化交易结算协议</li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Web3</h1><article class=default><h1 id=web3-基础设施及工具>Web3 基础设施及工具</h1><p>区块链的基础设施是非常重要的，这为开发者使用区块链、开发应用等提供了基础的支持，可以大大节省时间和资源。</p><h2 id=工具篇>工具篇</h2><p>TODO</p><h2 id=基础设施篇>基础设施篇</h2><ul><li><a href=https://nodereal.io/ target=_blank>nodereal</a> - Fastest, Reliable & Instant Web3 Infrastructure<ul><li><a href=https://docs.nodereal.io/docs/intro-nodereal target=_blank>nodereal docs</a></li><li><a href=https://nodereal.io/bnb-dev-tools target=_blank>bnb dev tools</a> - 里面包含了丰富的工具，值得拥有</li></ul></li><li><a href=https://www.quicknode.com/ target=_blank>quicknode</a> - The Blockchain Development Platform, Learn. Build. Scale.</li><li><a href=https://www.sendwyre.com/ target=_blank>wyre</a> - INFRASTRUCTURE FOR THE NEW ECONOMY, We put the power in your hands with easy-to-use APIs that you can use to delight your users with simple and secure payments and digital asset experiences</li></ul><footer class=footline></footer></article></section></section><article class=chapter><div class=article-subheading>Chapter 3</div><h1 id=distribute-service>Distribute Service</h1><p>总结分布式服务、互联网技术相关的知识。</p><ul class="children children-li children-sort-"><li><a href=/distribute-service/backend-storage/index.html>后端存储以及存储服务</a></li><li><a href=/distribute-service/bff/index.html>BFF</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Distribute Service</h1><article class=default><h1 id=后端存储以及存储服务>后端存储以及存储服务</h1><blockquote><p>把后端存储当成一个贯穿很多知识点的 Topic，这样可以把相关的知识点串联起来，形成一个完整的知识体系。</p></blockquote><p>后端存储是分布式服务中最重要的一部分。存储承担了数据的持久化、读写、查询等功能，一个安全可靠、快速稳定的存储基础设施是构建稳定的业务系统的基础。</p><p>根据不同的业务场景，选择使用不同的存储技术，是一种能力。</p><p>MySQL、Redis、ElasticSearch、HBase、Hive、MongoDB、RocksDB、CockroachDB 等等，这些存储还真就是谁都替代不了谁，每一种都有它擅长的地方，有它适用的场景，当然也有很突出的短板。如何根据业务系统的特点，选择合适的存储来构建我们的系统，是需要学习和掌握的。</p><p>目录列表</p><ul class="children children-li children-sort-"><li><a href=/distribute-service/backend-storage/cache/index.html>缓存设计</a></li></ul><p>TODOs</p><ul><li>分库分表<ul><li>ShardingSphere JDBC</li></ul></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of 后端存储以及存储服务</h1><article class=default><h1 id=缓存设计>缓存设计</h1><p>互联网服务中，缓存是提高系统性能的重要手段。缓存的设计需要考虑的因素很多，包括缓存的类型、缓存的位置、缓存的更新策略、缓存的一致性等等。本文将从这些方面来介绍缓存的设计。</p><h2 id=缓存>缓存</h2><blockquote><p>缓存，是一种存储数据的组件，它的作用是让对数据的请求更快地返回。实际上，凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为缓存。</p></blockquote><p>技术为业务服务，缓存也不例外；在业务系统中，主要会用到以下几种缓存：</p><ul><li>本地缓存 (aka 进程内缓存)</li><li>分布式缓存</li><li>类似于 CDN 的静态数据缓存</li></ul><h3 id=进程内缓存>进程内缓存</h3><p>一般也叫 <code>Local Cache</code>, 是指缓存在应用进程内部的缓存，比如 Java 中的 <code>HashMap</code>、<code>ConcurrentHashMap</code> 等。这种缓存的特点是速度快，但是缓存的数据量有限，一般只能缓存一些热点数据；此外，这类缓存会引入多实例下数据短暂不一致的问题，所以在使用的时候要格外小心。</p><p>经常使用的 <code>Local cache</code> 有：<code>Google Guava Cache</code>、<code>Caffeine</code>、<code>ConcurrentHashMap</code>、<code>Ehcache</code> 等。目前 <code>Caffeine</code> 是性能最好的 <code>Local Cache</code>。此外，<code>leveldb</code> 也是一种本地缓存的实现，但是它是基于磁盘的，所以性能不如上面几种。</p><h4 id=什么时候需要用本地缓存什么场景不适合用>什么时候需要用本地缓存？什么场景不适合用？</h4><p>举几个场景</p><ul><li>黑名单用户 ID / 白名单用户 ID；这种数据量不大，但是访问频率很高，所以可以用本地缓存，在启动时加载，运行过程中随着 Admin 的添加或者删除而更新</li><li>用户 ID 和 用户名、头像、昵称等的对应关系，由于某些原因我们一般指存储用户的 ID，当需要用户的其他信息时就需要从数据库中查询这些数据回来，如果每次都从 DB 中获取，显然对 DB 的压力很大，并且每次访问 DB 不是很有必要</li><li>分布式配置中心，为了降低业务服务对配置中心的压力，一般都是将数据缓存在本地，当有新的配置发布后，会通知业务服务中配置中心的 client，然后拉取新的配置，或者推送新的配置</li></ul><p><strong>总结一下</strong></p><ol><li>数据读多写少且对一致性要求不高的场景；如果一致性要求非常高，需要考虑使用分布式缓存，并且还要考虑数据库与分布式缓存的一致性问题</li><li>对性能要求极其严苛的场景，比如秒杀、抢购等</li><li>只读数据的场景</li><li>分布式缓存的普适性更强一些，很多场景都可以用分布式缓存来解决，如非必要，不建议使用本地缓存 (也就是说用了也要慎重)</li></ol><h4 id=优势是什么劣势是什么>优势是什么？劣势是什么？</h4><p><code>Local Cache</code> 和应用服务处于同一个进程内，且存储在内存中，一个字：快；无论对于 RT、QPS 还是吞吐量，都有极大增益。此外，也节省了内网带宽。</p><p>依据服务无状态设计的原则：<strong>尽量把数据的状态和存储放在专门的数据存储服务中，实例节点本身只做计算，不把数据状态和某个实例做耦合，这样在水平扩展时才能收放自如</strong>。本地缓存其实在一定程度上引入了状态，所以一个最需要关心的问题就是数据一致性，这一点有别于分布式缓存。</p><ul><li>本地缓存：每个实例都有一份缓存，需要协调数据一致性问题</li><li>分布式缓存：缓存数据集中存放在独立的缓存服务中，每个实例是不存在缓存数据的，但是需要考虑缓存和 SOR (Source of Record) 的一致性问题</li></ul><h4 id=目前有哪些本地缓存的实现方案各自的优缺点>目前有哪些本地缓存的实现方案，各自的优缺点？</h4><ul><li>编程语言的内置数据结构，比如 Java 中的 <code>HashMap</code>、<code>ConcurrentHashMap</code> 等</li><li>Google guava</li><li>Caffeine</li><li>Encache</li><li>Leveldb / Rocksdb</li></ul><h4 id=本地缓存关注的技术点是什么>本地缓存关注的技术点是什么？</h4><ul><li>缓存命中率</li><li>缓存容量</li><li>缓存淘汰策略</li><li>缓存一致性</li></ul><h3 id=分布式缓存>分布式缓存</h3><p>TODO</p><h2 id=缓存规范>缓存规范</h2><ul><li>JSR107</li><li>Spring Cache</li></ul><h2 id=缓存实践>缓存实践</h2><p>缓存可以应对高并发大流量的场景。</p><p>在做缓存设计时，有一些误区要避开：</p><ol><li>把缓存作为服务间传递数据的通道，这个要避免</li><li>使用缓存没有考虑雪崩的情况，这个要考虑</li><li>多服务共享一个缓存实例，这个最好要避免，多个服务之间缓存做垂直拆分</li></ol><p>找几个例子分析一下</p><hr><h2 id=references>References</h2><ul><li><input checked disabled type=checkbox> <a href=https://shniu.gitbook.io/cs/system-design/backend-store/cache-design target=_blank>缓存设计</a></li><li><input checked disabled type=checkbox> <a href=https://mp.weixin.qq.com/s/Car6EkaNzaJ7gaFa2EZxOw target=_blank>进程内缓存，究竟怎么玩？</a></li><li><input checked disabled type=checkbox> <a href=https://tech.meituan.com/2017/03/17/cache-about.html target=_blank>美团-缓存那些事儿</a></li><li><input disabled type=checkbox> <a href=https://weread.qq.com/web/reader/98a323b05e0b5e98afa107ckc81322c012c81e728d9d180 target=_blank>深入分布式缓存：从原理到实践</a></li></ul><h3 id=frameworks>Frameworks</h3><ul><li><a href=https://github.com/ben-manes/caffeine/wiki/Home-zh-CN target=_blank>Caffeine Doc</a></li></ul><p><a href=https://bbs.huaweicloud.com/blogs/365239 target=_blank>https://bbs.huaweicloud.com/blogs/365239</a>
<a href=https://mp.weixin.qq.com/s/36kVm4pfiy2vQEMToZ9--g target=_blank>https://mp.weixin.qq.com/s/36kVm4pfiy2vQEMToZ9--g</a>
<a href=https://cloud.tencent.com/developer/article/1546995 target=_blank>https://cloud.tencent.com/developer/article/1546995</a>
<a href=https://juejin.cn/post/6844903961078530062 target=_blank>https://juejin.cn/post/6844903961078530062</a>
<a href=https://mp.weixin.qq.com/s/YBpOz1dQ0sG15vGL7N0PeQ target=_blank>https://mp.weixin.qq.com/s/YBpOz1dQ0sG15vGL7N0PeQ</a>
<a href=https://shniu.gitbook.io/cs/middleware/redis target=_blank>https://shniu.gitbook.io/cs/middleware/redis</a>
<a href=https://shniu.gitbook.io/cs/system-design/backend-store/cache-design target=_blank>https://shniu.gitbook.io/cs/system-design/backend-store/cache-design</a>
<a href=https://tech.meituan.com/2017/03/17/cache-about.html target=_blank>https://tech.meituan.com/2017/03/17/cache-about.html</a>
<a href=http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html target=_blank>http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html</a>
<a href=https://juejin.cn/post/7151937376578142216 target=_blank>https://juejin.cn/post/7151937376578142216</a>
<a href=https://juejin.cn/column/7140852038258147358 target=_blank>https://juejin.cn/column/7140852038258147358</a></p><footer class=footline></footer></article></section><article class=default><h1 id=bff>BFF</h1><p>Backend for Frontend 是一种模式，在构建 API 时当然可以不选择使用 BFF，取而代之的是对多个 UI 终端提供一个统一的 API，但是不可避免的会带来一些问题：</p><ol><li>不同的 UI 终端展示的数据是不一样的，比如 Web H5 和 App 之间会存在较大的差异</li><li>不同的 UI 终端可能会有不同的逻辑，比如有些数据是 Web 用，有些则是 App 用，这样都放在一个接口里的话，对不同的终端来说，都会有一些无用的数据，或者是无用的逻辑，这样会导致接口的复杂度增加，维护成本增加；从节约流量和资源的角度说，移动端应该尽可能少的去拉取数据</li><li>统一的 API 在开发新功能时，可能会对不同 UI 终端都产生影响，而且功能逻辑会相互耦合；也就是说一个接口承担了更多的职责</li></ol><p>总结来看：由于不同终端的差异性，导致对后端 API 的数据产生了不同的需求，驱动我们去考虑针对不同的 UI 来定制不同的接口。</p><p><strong>通用的 API 后端和团队组成如下</strong></p><p><a href=#image-51048bbc813e67eb6442bc09ca713af8 class=lightbox-link><img src="/images/bff-single-api.jpeg?classes=shadow,inline&amp;height=300px" alt="通用 API 后端" class="shadow inline" style=height:300px;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-51048bbc813e67eb6442bc09ca713af8><img src="/images/bff-single-api.jpeg?classes=shadow,inline&amp;height=300px" alt="通用 API 后端" class=lightbox-image loading=lazy></a>
<a href=#image-3e4729a922576573074cb3d0c192351b class=lightbox-link><img src="/images/general-purpose-api-teams.jpeg?classes=shadow,inline&amp;height=300px" alt="通用 API 团队组成" class="shadow inline" style=height:300px;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-3e4729a922576573074cb3d0c192351b><img src="/images/general-purpose-api-teams.jpeg?classes=shadow,inline&amp;height=300px" alt="通用 API 团队组成" class=lightbox-image loading=lazy></a></p><h2 id=使用-bff>使用 BFF</h2><blockquote><p>The goal of the BFF pattern is to decouple the front-end applications from the back-end services and to reuse the APIs while ensuring that it doesn&rsquo;t cause over-fetching or over-requesting on the client-side. This is accomplished by developing a dedicated back-end for each front-end service. The BFF transforms the data into the correct format that the client application needs.</p></blockquote><p><a href=#image-909099c033221173fd5548b58897e2cf class=lightbox-link><img src="/images/bff-overview.jpeg?classes=shadow&amp;height=300px" alt="BFF Overview" class=shadow style=height:300px;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-909099c033221173fd5548b58897e2cf><img src="/images/bff-overview.jpeg?classes=shadow&amp;height=300px" alt="BFF Overview" class=lightbox-image loading=lazy></a></p><ol><li>BFF 的接口通常是由前端开发人员来定义，由后端开发人员来实现</li><li>BFF API 一般以 UI 为依据，这样更集中</li><li>至于是不是必须为每个类型的终端都定义不同的 BFF，这个需要根据实际情况来判断，或者团队来决定采用何种模式；比如 iOS 和 Android 的 UI 体验几乎完全一致，我们有必要指提供一套 BFF，而不是一个 iOS BFF 和一个 Android BFF；所以具体情况还要具体分析，没有一个标准答案</li><li>在调用多个下游服务时，使用 RxJava 或 <a href=https://twitter.github.io/finagle/ target=_blank>Finagle</a> 这类响应式编程风格的方式会更加的易于管理，而且可以更好的控制并发度，提高性能</li><li>在使用 BFF 时带来的最大困扰是重复代码，这个可能无法避免，但是在合理的情况下可以考虑复用代码、抽象代码达到消除重复的目的</li><li>一个指导规则可能是：如果被提取的功能不必同时更新，则使用共享库，但如果需要，则使用服务。</li><li>谈论复制和重用，不要试图从一开始就让一切通用。如果你尝试，并且它在整个组织中使用，就会引起摩擦，因为很多人都想做出贡献。在考虑通用用法之前，请专注于您的功能和特定用例。“特殊功能优先于通用用法”策略效果更好。在考虑提取代码时，不要忘记有用的“三法则”。</li></ol><p>关于 BFF 的实践可以看一下 <a href=https://www.thoughtworks.com/insights/blog/bff-soundcloud title="BFF Soundcloud" target=_blank>BFF @ SoundCloud</a> 这篇文章，里面有一些很好的实践经验。</p><p><strong>什么时候用 BFF ?</strong> 当你有多个微服务，并且需要应对不同的 UI 终端，而且这些终端之间存在差异性，可以考虑使用 BFF 模式。</p><h2 id=event-driven-bff>Event-driven BFF</h2><p>AWS 提出了一个 event-driven BFF 的东西: <a href=https://aws.amazon.com/cn/blogs/mobile/backends-for-frontends-pattern/ title="AWS event-driven BFF" target=_blank>Backends for Frontends Pattern by AWS</a></p><p><a href=#image-13b79dbf98fa43d8634336d750625341 class=lightbox-link><img src="/images/aws-event-driven-bff-1.png?classes=shadow" alt="AWS event driven BFF" class=shadow style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-13b79dbf98fa43d8634336d750625341><img src="/images/aws-event-driven-bff-1.png?classes=shadow" alt="AWS event driven BFF" class=lightbox-image loading=lazy></a></p><ul><li>右边是微服务或单体服务发出的 event，这些 event 在 Domain 发生更新时发出</li><li>中间是 Event bus，接收 event 后转发给左边的 BFF 层的订阅者</li><li>左边是 BFF 的实现，不同的 BFF 可以有不同的数据库投影，根据具体的需求来定制数据结构，当然也可以支持 CDC 模式</li></ul><p>还有一种更加云原生的方式来构建服务</p><p><a href=#image-0f0b94045549a55d11893be884ebbaca class=lightbox-link><img src="/images/aws-event-driven-bff-2.png?classes=shadow" alt="AWS event driven BFF" class=shadow style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox id=image-0f0b94045549a55d11893be884ebbaca><img src="/images/aws-event-driven-bff-2.png?classes=shadow" alt="AWS event driven BFF" class=lightbox-image loading=lazy></a></p><h2 id=reference>Reference</h2><ul><li><a href=https://samnewman.io/patterns/architectural/bff/ target=_blank>Pattern: Backends For Frontends</a> - Sam Newman 写的关于 BFF 模式的文章</li><li><a href=https://developer.aliyun.com/article/841664 target=_blank>BFF 架构简介</a></li><li><a href=https://www.thoughtworks.com/insights/blog/bff-soundcloud title="BFF Soundcloud" target=_blank>BFF @ SoundCloud</a></li><li><a href=https://www.codemag.com/Article/2203081/A-Deep-Dive-into-the-Back-End-for-Front-End-Pattern target=_blank>A Deep Dive into the Back-End for Front-End Pattern</a></li><li><a href=https://aws.amazon.com/cn/blogs/mobile/backends-for-frontends-pattern/ title="AWS event-driven BFF" target=_blank>Backends for Frontends Pattern</a></li><li><a href=https://netflixtechblog.com/seamlessly-swapping-the-api-backend-of-the-netflix-android-app-3d4317155187 target=_blank>Seamlessly Swapping the API backend of the Netflix Android app</a> - Netflix Android App 的 BFF 实践</li><li><a href=https://medium.com/mobilepeople/backend-for-frontend-pattern-why-you-need-to-know-it-46f94ce420b0 target=_blank>Backend for frontend (BFF) pattern— why do you need to know it?</a></li><li><a href=https://learn.microsoft.com/en-us/azure/architecture/patterns/backends-for-frontends target=_blank>Backends for Frontends pattern by Azure</a></li></ul><footer class=footline></footer></article></section><article class=chapter><div class=article-subheading>Chapter 4</div><h1 id=programming-language>Programming Language</h1><p>编程语言相关的知识。</p><ul class="children children-li children-sort-"><li><a href=/programming-language/java/index.html>Java</a></li><li><a href=/programming-language/golang/index.html>Golang</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Programming Language</h1><article class=chapter><div class=article-subheading>Chapter 1</div><h1 id=java>Java</h1><p>Java 是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级 Web 应用开发和移动应用开发。</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Java</h1><article class=default><h1 id=jdk-新特性>JDK 新特性</h1><p>从 JDK8 开始，Java 做了非常大的改进，这反映出 Java 不是一个保守禁锢的语言，而是一个适应时代变化、进化的语言，去努力吸收其他语言的优秀特性。</p><p>TODO</p><ol><li><a href=https://pretius.com/blog/java-17-features/ target=_blank>https://pretius.com/blog/java-17-features/</a></li><li><a href="https://www.evm.codes/playground?fork=shanghai" target=_blank>https://www.evm.codes/playground?fork=shanghai</a></li><li><a href=https://mirror.xyz/xyyme.eth/dsU7KoQLyqiHrY0bQX2ETq1zkDYiW-3PtzxfzGwRdss target=_blank>https://mirror.xyz/xyyme.eth/dsU7KoQLyqiHrY0bQX2ETq1zkDYiW-3PtzxfzGwRdss</a></li></ol><h2 id=new-features>New Features</h2><ol><li>JDK8 ~ JDK20 的新特性</li><li>对开发人员有哪些影响</li></ol><ul><li><p>JDK8</p><ul><li>Lambda 表达式</li><li>Stream API</li><li>Optional 类</li><li>新的日期时间 API</li><li>Nashorn JavaScript 引擎</li><li>Base64</li><li>并行数组</li><li>并发 API</li><li>Type Annotations</li><li>IO 新增</li><li>JVM 新增</li></ul></li><li><p>JDK9</p><ul><li>JShell</li><li>模块化系统</li><li>HTTP 2 客户端</li><li>改进的 Javadoc</li><li>改进的 Stream API</li><li>Reactive Streams</li><li>改进的 CompletableFuture</li><li>改进的 Optional</li><li>改进的 @Deprecated 注解</li><li>改进的 try-with-resources</li><li>改进的 Diamond 操作符</li><li>改进的 Process API</li><li>改进的 JVM</li><li>改进的 GC</li><li>改进的 IO</li><li>改进的 CORBA</li><li>改进的 RMI</li><li>改进的 JMX</li><li>改进的 JAXP</li><li>改进的 JAXB</li><li>改进的 JAX-WS</li><li>改进的 JAX-RS</li><li>改进的 JMS</li><li>改进的 JDBC</li><li>改进的 JNDI</li></ul></li><li><p>JDK10</p><ul><li>局部变量类型推断</li><li>基于时间的版本控制</li><li>并行 Full GC</li><li>改进的 G1 GC</li><li>改进的 Parallel GC</li><li>改进的 CMS GC</li><li>改进的 ZGC</li><li>改进的 Shenandoah GC</li><li>改进的 JVM</li><li>改进的 IO</li><li>改进的 JAXP</li><li>改进的 JAX-WS</li><li>改进的 JAX-RS</li><li>改进的 JMS</li><li>改进的 JDBC</li><li>改进的 JNDI</li></ul></li><li><p>JDK11</p><ul><li>HTTP Client</li><li>改进的 GC</li><li>改进的 JVM</li><li>改进的 IO</li><li>改进的 JAXP</li><li>改进的 JAX-WS</li><li>改进的 JAX-RS</li><li>改进的 JMS</li><li>改进的 JDBC</li><li>改进的 JNDI</li></ul></li></ul><footer class=footline></footer></article><article class=default><h1 id=jvm>JVM</h1><p>JVM 是 Java 虚拟机的缩写，是运行 Java 字节码的虚拟机。</p><h2 id=jvm-基础>JVM 基础</h2><p>Java 中的引用：强引用、软引用、弱引用、虚引用。</p><p>不同类型的引用和 GC 有密切的关系。</p><h2 id=jvm-内存模型>JVM 内存模型</h2><p>TODO</p><h2 id=jvm-gc>JVM GC</h2><p>TODO</p><footer class=footline></footer></article></section><article class=chapter><div class=article-subheading>Chapter 2</div><h1 id=golang>Golang</h1><p>不需要面面俱到的记录和 Copy，只记录自己的一些疑惑，以及一些有意思的东西。</p><h2 id=golang-基础知识>Golang 基础知识</h2><p>Golang 的数据类型有哪些？引用类型和值类型的区别？什么时候用引用类型，什么时候用值类型？</p><h2 id=golang-文件系统操作>Golang 文件系统操作</h2><ul><li><a href=https://colobu.com/2016/10/12/go-file-operations/ target=_blank>[译]Go文件操作大全</a></li><li><a href=https://freshman.tech/snippets/go/create-directory-if-not-exist/ target=_blank>How to create a directory if it does not exist in Go</a></li></ul><h2 id=reference>Reference</h2><ul><li><a href=https://github.com/shniu/gostuff target=_blank>Everything about Golang</a> - 之前记录的一些笔记</li></ul><footer class=footline></footer></article></section></section></div></main></div><script src=/js/clipboard.min.js?1704121548 defer></script>
<script src=/js/perfect-scrollbar.min.js?1704121548 defer></script>
<script src=/js/d3/d3-color.min.js?1704121548 defer></script>
<script src=/js/d3/d3-dispatch.min.js?1704121548 defer></script>
<script src=/js/d3/d3-drag.min.js?1704121548 defer></script>
<script src=/js/d3/d3-ease.min.js?1704121548 defer></script>
<script src=/js/d3/d3-interpolate.min.js?1704121548 defer></script>
<script src=/js/d3/d3-selection.min.js?1704121548 defer></script>
<script src=/js/d3/d3-timer.min.js?1704121548 defer></script>
<script src=/js/d3/d3-transition.min.js?1704121548 defer></script>
<script src=/js/d3/d3-zoom.min.js?1704121548 defer></script>
<script src=/js/mermaid.min.js?1704121548 defer></script>
<script>window.themeUseMermaid=JSON.parse("{}")</script><script src=/js/theme.js?1704121548 defer></script></body></html>